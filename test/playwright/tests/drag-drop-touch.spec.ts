/**
 * Touch-based drag and drop tests
 *
 * Note: The DragManager uses mouse events. On touch devices, browsers automatically
 * translate touch events to mouse events (touchstart → mousedown, touchmove → mousemove,
 * touchend → mouseup). These tests verify that the drag behavior works correctly for
 * touch users by simulating the mouse events that would be generated by touch input.
 *
 * Touch devices rely on this browser compatibility layer for pointer-based drag & drop.
 */
import { expect, test } from '@playwright/test';
import type { Page } from '@playwright/test';
import type { Blok } from '@/types';
import type { OutputData } from '@/types';
import { ensureBlokBundleBuilt, TEST_PAGE_URL } from './helpers/ensure-build';
import { DATA_ATTR, createSelector } from '../../../src/components/constants';

const HOLDER_ID = 'blok';
const SETTINGS_BUTTON_SELECTOR = `${createSelector(DATA_ATTR.interface)} [data-blok-testid="settings-toggler"]`;

/**
 * Helper function to get block text data from saved output.
 */
const getBlockText = (block: { data: unknown } | undefined): string => {
  if (!block) {
    throw new Error('Block is undefined');
  }
  return (block.data as { text: string }).text;
};

/**
 * Helper function to get bounding box and throw if it doesn't exist.
 */
const getBoundingBox = async (
  locator: ReturnType<Page['locator']>
): Promise<{ x: number; y: number; width: number; height: number }> => {
  const box = await locator.boundingBox();

  if (!box) {
    throw new Error('Could not get bounding box for element');
  }

  return box;
};

/**
 * Helper function to perform drag and drop simulating touch-to-mouse events.
 * Touch devices generate mouse events through browser compatibility layer.
 *
 * @param page Playwright page instance
 * @param sourceLocator Locator for the element to drag
 * @param targetLocator Locator for the target element
 * @param targetVerticalPosition Where to drop on target
 */
const performTouchLikeDragDrop = async (
  page: Page,
  sourceLocator: ReturnType<Page['locator']>,
  targetLocator: ReturnType<Page['locator']>,
  targetVerticalPosition: 'top' | 'bottom'
): Promise<void> => {
  const sourceBox = await getBoundingBox(sourceLocator);
  const targetBox = await getBoundingBox(targetLocator);

  const sourceX = sourceBox.x + sourceBox.width / 2;
  const sourceY = sourceBox.y + sourceBox.height / 2;
  const targetX = targetBox.x + targetBox.width / 2;
  const targetY = targetVerticalPosition === 'top'
    ? targetBox.y + 1
    : targetBox.y + targetBox.height - 1;

  // Touch devices: press and hold (translates to mousedown)
  await page.mouse.move(sourceX, sourceY);
  await page.mouse.down();

  // Wait for drag initialization (touch devices have similar delay)
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(50);

  // Move to target position with steps to simulate continuous touch movement
  await page.mouse.move(targetX, targetY, { steps: 10 });

  // Wait for drop target detection
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(50);

  // Release to complete drop (translates to touchend)
  await page.mouse.up();

  // Wait for state updates
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(100);
};

type CreateBlokOptions = {
  data?: OutputData;
  config?: Record<string, unknown>;
};

declare global {
  interface Window {
    blokInstance?: Blok;
    Blok: new (...args: unknown[]) => Blok;
  }
}

const createBlok = async (page: Page, options: CreateBlokOptions = {}): Promise<void> => {
  const { data = null, config = {} } = options;

  await page.evaluate(async ({ holder, data: initialData, config: blokConfig }) => {
    if (window.blokInstance) {
      await window.blokInstance.destroy?.();
      window.blokInstance = undefined;
    }

    document.getElementById(holder)?.remove();

    const container = document.createElement('div');

    container.id = holder;
    container.style.border = '1px dotted #388AE5';

    document.body.appendChild(container);

    const configToUse: Record<string, unknown> = {
      holder: holder,
      ...blokConfig,
    };

    if (initialData) {
      configToUse.data = initialData;
    }

    const blok = new window.Blok(configToUse);

    window.blokInstance = blok;
    await blok.isReady;
  }, {
    holder: HOLDER_ID,
    data,
    config,
  });
};

test.describe('touch-based drag and drop', () => {
  test.beforeAll(() => {
    ensureBlokBundleBuilt();
  });

  test.beforeEach(async ({ page }) => {
    await page.goto(TEST_PAGE_URL);
    await page.waitForFunction(() => typeof window.Blok === 'function');
  });

  test('should move block using touch-like input', async ({ page }) => {
    const blocks = [
      {
        type: 'paragraph',
        data: { text: 'First block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Second block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Third block' },
      },
    ];

    await createBlok(page, {
      data: { blocks },
    });

    // Hover over the first block to show the settings button
    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();
    const targetBlock = page.getByTestId('block-wrapper').filter({ hasText: 'Third block' });

    // Perform touch-like drag and drop
    await performTouchLikeDragDrop(page, settingsButton, targetBlock, 'bottom');

    // Verify the new order in DOM
    await expect(page.getByTestId('block-wrapper')).toHaveText([
      'Second block',
      'Third block',
      'First block',
    ]);

    // Verify the new order in Blok data
    const savedData = await page.evaluate(() => window.blokInstance?.save());

    expect(getBlockText(savedData?.blocks[0])).toBe('Second block');
    expect(getBlockText(savedData?.blocks[1])).toBe('Third block');
    expect(getBlockText(savedData?.blocks[2])).toBe('First block');
  });

  test('should show dragging state during touch-like drag', async ({ page }) => {
    const blocks = [
      {
        type: 'paragraph',
        data: { text: 'First block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Second block' },
      },
    ];

    await createBlok(page, {
      data: { blocks },
    });

    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();

    const sourceBox = await getBoundingBox(settingsButton);

    // Start touch-like drag (press and hold)
    await page.mouse.move(sourceBox.x + sourceBox.width / 2, sourceBox.y + sourceBox.height / 2);
    await page.mouse.down();

    // Wait and move to trigger drag
    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(50);
    await page.mouse.move(sourceBox.x + 50, sourceBox.y + 50);

    // Verify dragging state is active
    const blokWrapper = page.locator('[data-blok-dragging="true"]');

    await expect(blokWrapper).toHaveCount(1);

    // End the drag
    await page.mouse.up();

    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(100);

    // Verify dragging state is cleared
    await expect(blokWrapper).toHaveCount(0);
  });

  test('should cancel when touch-like input ends without moving past threshold', async ({ page }) => {
    const blocks = [
      {
        type: 'paragraph',
        data: { text: 'First block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Second block' },
      },
    ];

    await createBlok(page, {
      data: { blocks },
    });

    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();

    const sourceBox = await getBoundingBox(settingsButton);

    // Start touch-like input (press)
    await page.mouse.move(sourceBox.x + sourceBox.width / 2, sourceBox.y + sourceBox.height / 2);
    await page.mouse.down();

    // Wait and end without moving past threshold
    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(50);
    await page.mouse.up();

    // Verify blocks are still in original order (no drag occurred)
    await expect(page.getByTestId('block-wrapper')).toHaveText([
      'First block',
      'Second block',
    ]);
  });

  test('should move block (not duplicate) without Alt key for touch-like input', async ({ page }) => {
    // Note: Touch devices don't have an Alt key equivalent for duplication
    // This test documents that touch-like input moves blocks by default
    const blocks = [
      {
        type: 'paragraph',
        data: { text: 'First block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Second block' },
      },
    ];

    await createBlok(page, {
      data: { blocks },
    });

    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();

    const sourceBox = await getBoundingBox(settingsButton);
    const targetBlock = page.getByTestId('block-wrapper').filter({ hasText: 'Second block' });
    const targetBox = await getBoundingBox(targetBlock);

    // Start touch-like input
    await page.mouse.move(sourceBox.x + sourceBox.width / 2, sourceBox.y + sourceBox.height / 2);
    await page.mouse.down();

    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(50);

    // Move to target
    await page.mouse.move(targetBox.x + targetBox.width / 2, targetBox.y + targetBox.height - 1);

    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(50);

    // End touch (no Alt key equivalent in touch, so this will move, not duplicate)
    await page.mouse.up();

    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(100);

    // Verify block moved (not duplicated)
    await expect(page.getByTestId('block-wrapper')).toHaveCount(2);
    await expect(page.getByTestId('block-wrapper')).toHaveText([
      'Second block',
      'First block',
    ]);
  });
});

test.describe('touch-based drag with nested lists', () => {
  test.beforeAll(() => {
    ensureBlokBundleBuilt();
  });

  test.beforeEach(async ({ page }) => {
    await page.goto(TEST_PAGE_URL);
    await page.waitForFunction(() => typeof window.Blok === 'function');
  });

  /**
   * Helper to create list item blocks with depth support.
   */
  const createListBlocks = (
    items: Array<{ text: string; depth?: number }>
  ): OutputData['blocks'] => items.map((item, index) => ({
    id: `list-${index}`,
    type: 'list',
    data: {
      text: item.text,
      style: 'unordered',
      ...(item.depth !== undefined && item.depth > 0 ? { depth: item.depth } : {}),
    },
  }));

  test('should drag parent list item with nested children using touch-like input', async ({ page }) => {
    // Create a list with parent and nested children:
    // - First (depth 0) <- parent
    //   - Nested A (depth 1) <- child
    //   - Nested B (depth 1) <- child
    // - Second (depth 0)
    const blocks = createListBlocks([
      { text: 'First' },
      { text: 'Nested A', depth: 1 },
      { text: 'Nested B', depth: 1 },
      { text: 'Second' },
    ]);

    await createBlok(page, {
      data: { blocks },
    });

    // Hover over the first block (parent) to show settings button
    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();

    // Drag to the bottom of the last block
    const targetBlock = page.getByTestId('block-wrapper').filter({ hasText: 'Second' });

    await performTouchLikeDragDrop(page, settingsButton, targetBlock, 'bottom');

    // Verify the new order: parent and children moved together after "Second"
    const savedData = await page.evaluate(() => window.blokInstance?.save());

    expect(getBlockText(savedData?.blocks[0])).toBe('Second');
    expect(getBlockText(savedData?.blocks[1])).toBe('First');
    expect(getBlockText(savedData?.blocks[2])).toBe('Nested A');
    expect(getBlockText(savedData?.blocks[3])).toBe('Nested B');
  });
});

test.describe('touch device viewport interactions', () => {
  test.beforeAll(() => {
    ensureBlokBundleBuilt();
  });

  test.beforeEach(async ({ page }) => {
    await page.goto(TEST_PAGE_URL);
    await page.waitForFunction(() => typeof window.Blok === 'function');
  });

  test('should show toolbar after touch-like drag completes', async ({ page }) => {
    const blocks = [
      {
        type: 'paragraph',
        data: { text: 'First block' },
      },
      {
        type: 'paragraph',
        data: { text: 'Second block' },
      },
    ];

    await createBlok(page, {
      data: { blocks },
    });

    const firstBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await firstBlock.hover();

    const settingsButton = page.locator(SETTINGS_BUTTON_SELECTOR);

    await expect(settingsButton).toBeVisible();

    const targetBlock = page.getByTestId('block-wrapper').filter({ hasText: 'Second block' });

    // Perform touch-like drag
    await performTouchLikeDragDrop(page, settingsButton, targetBlock, 'bottom');

    // After drag completes, hover over a block to check toolbar
    const secondBlock = page.getByTestId('block-wrapper').filter({ hasText: 'First block' });

    await secondBlock.hover();

    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(100);

    // Verify toolbar is visible again
    const toolbar = page.locator('[data-blok-testid="toolbar"][data-blok-opened="true"]');

    await expect(toolbar).toHaveCount(1);
  });
});
