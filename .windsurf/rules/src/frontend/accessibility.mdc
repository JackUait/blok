---
alwaysApply: true
description: Enforce accessibility best practices so all users can use the application
---

### Accessibility guidance (must follow)

- Semantics first
  - Prefer semantic HTML (`button`, `a`, `nav`, `main`, `header`, `footer`, `ul/ol/li`, `table/th/td`) over generic `div`/`span`.
  - Use `button` for actions and `a`/`Link` for navigation. Do not use click handlers on non-interactive elements. If unavoidable, add `role="button"`, `tabIndex={0}`, and keyboard handlers for Enter/Space.

- Keyboard support
  - All interactive controls must be reachable via Tab and operable via keyboard.
  - Do not remove focus outlines. If customizing, ensure visible `:focus-visible` styles with sufficient contrast.
  - Preserve a logical tab order; avoid `tabIndex` > 0.

- Focus management
  - On opening modals/drawers/popovers: move focus inside, trap focus, and restore focus to the trigger on close.
  - Provide a skip link to main content (e.g., `href="#main"`) and landmark roles (`<main>`, `<nav>`, `<header>`, `<footer>`).

- Images and media
  - Every `img` must have an appropriate `alt`. If decorative, use `alt=""` and `aria-hidden="true"`.
  - Provide captions/subtitles for video/audio when applicable.
  - For lazy-loaded images with skeletons, mark skeletons `aria-hidden="true"` and set container `aria-busy` while loading.

- Forms
  - Inputs require visible labels bound via `<label htmlFor>` or `aria-label`/`aria-labelledby`.
  - Indicate errors with `aria-invalid` and associate helper/error text via `aria-describedby`.

- Live updates and async content
  - For dynamic status (loading/completion), use `aria-live="polite"` (or `assertive` if critical).
  - Spinners should have `aria-label` or be hidden (`aria-hidden="true"`) with a separate live region announcing status.

- Headings and structure
  - Maintain a logical heading hierarchy without skipping levels.
  - Use list semantics for collections.

- Color and contrast
  - Ensure WCAG 2.1 AA contrast: 4.5:1 for normal text and 3:1 for large or bold text and UI components, including focus and hover states. When placing text over images, add an overlay or background.
  - Do not convey information by color alone; add icons/text.

- Motion and reduced motion
  - Respect `prefers-reduced-motion: reduce`. Disable or simplify non-essential animations.
  - In React animations, gate effects with `gsap.matchMedia('(prefers-reduced-motion: no-preference)')` and provide a reduced-motion path.
  - Example usage exists in [AnnouncementsFeedContent.tsx](mdc:src/frontend/src/features/AnnouncementsFeed/ui/AnnouncementsFeedContent.tsx).
  - Vanilla CSS example using the `prefers-reduced-motion` media query:

```css
/* Default animations */
.card {
  transition: transform 300ms ease, opacity 300ms ease;
}
.card:hover {
  transform: translateY(-4px);
  opacity: 0.95;
}

/* Reduced motion: remove transforms and long transitions */
@media (prefers-reduced-motion: reduce) {
  * {
    animation: none !important;
    transition-duration: 0.01ms !important; /* effectively no transition */
    scroll-behavior: auto !important;
  }
  .card:hover {
    transform: none;
    opacity: 1;
  }
}
```

- Tables and data
  - Use `<th scope>` for headers, provide captions when helpful. Avoid layout tables.

- Testing
  - Prefer `@testing-library` queries by role/name (`getByRole`, `getByLabelText`) to reflect real accessibility.

### React implementation tips

- Announce route changes by updating `document.title` and placing page content in a `<main id="main">` region.
- When building composite widgets (tabs, accordions), follow the relevant ARIA patterns (roles, `aria-selected`, `aria-controls`) only when semantics are not achievable with native elements.
- For card components that wrap links, ensure the entire card is a single focusable link (as with `Link`) and include descriptive link text or `aria-label` if needed.

### Code patterns

```tsx
// Accessible button vs. link
<button type="button" onClick={handleAction}>Do action</button>
<Link to="/path">Go to details</Link>

// Custom interactive element (only if you cannot use <button>)
<div
  role="button"
  tabIndex={0}
  onKeyDown={(e) => {
    const isEnter = e.key === 'Enter' || e.code === 'Enter';
    const isSpace = e.key === ' ' || e.key === 'Spacebar' || e.code === 'Space';

    if (isEnter) {
      onClick();
    }
    if (isSpace) {
      e.preventDefault();
    }
  }}
  onKeyUp={(e) => {
    const isSpace = e.key === ' ' || e.key === 'Spacebar' || e.code === 'Space';
    if (isSpace) {
      onClick();
    }
  }}
  onClick={onClick}
/>
```

### Notes

- Use ARIA to enhance semantics, not replace them. Avoid redundant roles on native elements.
- If a component is purely decorative (e.g., background clouds), set `aria-hidden="true"` and remove from the tab order.
